package {{service.namespace}}.configuration

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.ApplicationContext
import org.springframework.util.StreamUtils
import org.springframework.beans.factory.annotation.Value
import graphql.GraphQL
import graphql.schema.GraphQLSchema
import graphql.schema.idl.SchemaParser
import graphql.schema.idl.SchemaGenerator
import graphql.schema.idl.RuntimeWiring
import graphql.schema.visibility.BlockedFields
import graphql.schema.visibility.GraphqlFieldVisibility
import graphql.execution.AsyncExecutionStrategy
import graphql.execution.DataFetcherExceptionHandler
import graphql.scalars.ExtendedScalars
import org.dataloader.DataLoaderRegistry
import org.slf4j.LoggerFactory
import java.nio.charset.StandardCharsets

import {{service.namespace}}.graphql.type.QueryResolver
{{#each service.graphql_types as |graphql_type| ~}}
import {{service.namespace}}.graphql.type.{{lower-snake graphql_type.name}}.*
{{/each}}

@Configuration
class GraphqlConfig(
    @Value("\${graphql.blocked-fields-patterns:}")
    private val blockedFieldsPatterns: String,
) {
    @Bean
    fun graphql(
        schema: GraphQLSchema,
        exceptionHandler: DataFetcherExceptionHandler?,
        fieldFilteringInstrument: GraphqlFieldFilteringInstrument,
    ): GraphQL = GraphQL
        .newGraphQL(schema)
        .instrumentation(fieldFilteringInstrument)
        .apply { if (exceptionHandler != null) queryExecutionStrategy(AsyncExecutionStrategy(exceptionHandler)) }
        .build()

    @Bean
    fun fieldFilteringInstrument(
        fieldFilteringRules: List<GraphqlFieldFilteringRule<*>>
    ): GraphqlFieldFilteringInstrument = GraphqlFieldFilteringInstrument(fieldFilteringRules)

    @Bean
    fun blockedFields(): GraphqlFieldVisibility = blockedFieldsPatterns
        .split(",")
        .fold(BlockedFields.newBlock()) { block, pattern ->
            LOG.info("Ignoring the following graphql fields: {}", pattern)
            block.addPattern(pattern)
        }
        .build()

    @Bean
    fun buildSchema(
        context: ApplicationContext,
        runtimeWiring: RuntimeWiring
    ): GraphQLSchema {
        val parser = SchemaParser()
        val schema = context
            .getResources("classpath*:/**/*.graphql")
            .map {
                StreamUtils.copyToString(it.inputStream, StandardCharsets.UTF_8)
            }
            .joinToString("\n")
        val typeRegistry = parser.parse(schema)
        return SchemaGenerator().makeExecutableSchema(typeRegistry, runtimeWiring)
    }

    @Bean
    fun buildRuntimeWiring(
        queryResolver: QueryResolver,
        {{#each service.graphql_types as |graphql_type| ~}}
        {{lower-camel graphql_type.name}}Resolver: {{upper-camel graphql_type.name}}Resolver,
        {{/each}}
        {{#each service.graphql_types_backed_by_indexed_document as |graphql_type| ~}}
        {{define "index_name" graphql_type.elasticsearch_index.name ~}}
        {{lower-camel index_name}}DocumentResolver: {{upper-camel index_name}}DocumentResolver,
        {{/each}}
        fieldVisibility: GraphqlFieldVisibility,
    ): RuntimeWiring = RuntimeWiring.newRuntimeWiring()
    .scalar(ExtendedScalars.newRegexScalar("DateTime").addPattern(
        """^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z?$""".toPattern()
    ).build())
    .scalar(ExtendedScalars.newRegexScalar("Date").addPattern(
        """^[0-9]{4}-[0-9]{2}-[0-9]{2}$""".toPattern()
    ).build())
    .scalar(ExtendedScalars.Time)
    .also {
        queryResolver.registerFetcher(it)
        {{#each service.graphql_types as |graphql_type| ~}}
        {{lower-camel graphql_type.name}}Resolver.registerFetcher(it)
        {{/each}}
        {{#each service.graphql_types_backed_by_indexed_document as |graphql_type| ~}}
        {{define "index_name" graphql_type.elasticsearch_index.name ~}}
        {{lower-camel index_name}}DocumentResolver.registerFetcher(it)
        {{/each}}
    }
    .fieldVisibility(fieldVisibility)
    .build()

    @Bean
    fun buildDataLoaderRegistry(
        {{#each service.graphql_type_relationships as |relationship| ~}}
        {{#if (eq relationship.type 'indexed_document') ~}}
        {{lower-camel relationship.resolver_name}}: {{upper-camel relationship.resolver_name}},
        {{/if}}
        {{/each}}
    ): DataLoaderRegistry = DataLoaderRegistry().also {
        {{#each service.graphql_type_relationships as |relationship| ~}}
        {{#if (eq relationship.type 'indexed_document') ~}}
        {{lower-camel relationship.resolver_name}}.registerLoader(it)
        {{/if}}
        {{/each}}
    }

    companion object {
        val LOG = LoggerFactory.getLogger(GraphqlConfig::class.java)
    }
}