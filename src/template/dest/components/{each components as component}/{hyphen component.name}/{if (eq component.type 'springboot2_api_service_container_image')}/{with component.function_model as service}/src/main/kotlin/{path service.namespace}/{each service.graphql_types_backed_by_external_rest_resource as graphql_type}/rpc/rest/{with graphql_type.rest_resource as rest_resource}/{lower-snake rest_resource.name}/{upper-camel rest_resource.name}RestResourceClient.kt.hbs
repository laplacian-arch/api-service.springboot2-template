{{define "base_package" (concat service.namespace '.rpc.rest') ~}}
{{define "package" (concat base_package '.' (lower-snake rest_resource.name)) ~}}
{{define "depends_on_cache" (any rest_resource.operations '@it.effective_cache_policy') ~}}
{{define "base_class_name" (upper-camel rest_resource.name) ~}}
{{define "class_name" (concat base_class_name 'RestResourceClient') ~}}
package {{package}}

import org.springframework.stereotype.Component
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpMethod
{{#if depends_on_cache ~}}
import org.springframework.cache.CacheManager
{{~/if}}
import graphql.GraphQLContext
import reactor.core.publisher.Mono
import com.fasterxml.jackson.module.kotlin.*
import org.slf4j.*

import {{base_package}}.RestResourceClientBase
{{#each rest_resource.operations as |operation| ~}}
import {{package}}.{{lower-snake operation.name}}.*
{{/each}}

@Component
class {{class_name}}(
    {{#each rest_resource.configurations as |config| ~}}
    @Value("{{concat '\${' config.definition.key '}'}}")
    private val {{config.variable_name}}: {{upper-camel config.definition.type}},
    {{/each}}
    {{#if depends_on_cache ~}}
    private val cacheManager: CacheManager,
    {{~/if}}
): RestResourceClientBase(), {{upper-camel rest_resource.name}}RestResource {
    {{#each rest_resource.operations as |operation| ~}}
    {{define 'operation_name' (lower-camel operation.name) ~}}
    {{define 'operation_class_base_name' (upper-camel operation.name) ~}}
    {{define 'input_class_name' (concat operation_class_base_name 'Input') ~}}
    {{define 'response_class_name' (concat operation_class_base_name 'Response') ~}}
    {{define 'cache_policy' operation.effective_cache_policy ~}}
    /**
     * {{trim operation.description}}
     */
    override fun {{operation_name}}({{#if operation.arguments}}input: {{input_class_name}}, {{/if}}context: GraphQLContext): Mono<{{response_class_name}}> {{if cache_policy '=' '{'}}
        {{#if cache_policy ~}}
        withCache(
            cacheManager.getCache("{{cache_policy.key}}")!!
        {{#if operation.arguments ~}}
        ) { params: {{input_class_name}} -> {{operation_name}}NoCache(params, context) }(input)
        {{else ~}}
        ) { _ -> {{operation_name}}NoCache(context) }("")
        {{/if}}

    private fun {{operation_name}}NoCache({{#if operation.arguments}}input: {{input_class_name}}, {{/if}}context: GraphQLContext): Mono<{{response_class_name}}> {
        {{~/if}}
        {{#each operation.arguments as |argument| ~}}
        val {{lower-camel argument.name}} = input.{{lower-camel argument.name}}
        {{/each}}
        return client({{dquote rest_resource.base_url}})
        .method(HttpMethod.{{upper-snake operation.method}})
        .uri { it
            .path({{dquote operation.path}})
            {{#each operation.query_parameters as |parameter| ~}}
            .let { {{if parameter.multiple 'queryParams' 'queryParam'}}(it, {{dquote parameter.name}}, {{dquote parameter.value}}) }
            {{/each}}
            .build({{#if operation.path_parameters ~}}mapOf(
                {{#each operation.path_parameters as |param| ~}}
                "{{lower-camel param.name}}" to {{dquote param.value}},
                {{/each}}
            ){{~/if}})
        }
        .let { commonRequestSettings(it, context) }
        {{#each operation.http_headers as |header| ~}}
        .header({{dquote header.name}}, {{dquote header.value}})
        {{/each}}
        .exchange()
        .flatMap { response ->
            {{#if rest_resource.enable_automatic_cookie_handling ~}}
            handleResponseCookies(response, context)
            {{/if}}
            response.bodyToMono({{upper-camel operation.name}}Response::class.java)
        }
    }
    {{/each}}

    companion object {
        private val LOG: Logger = LoggerFactory.getLogger({{class_name}}::class.java)
    }
}