{{define 'class_base_name' (upper-camel graphql_field.name) ~}}
{{define 'fetcher_class_name' (concat class_base_name 'FieldFetcher') ~}}
{{define 'arguments_class_name' (concat class_base_name 'FieldArguments') ~}}
{{define 'repository_class_name' (concat (upper-camel graphql_type.name) 'Repository') ~}}
{{define 'record_class_name' (upper-camel graphql_type.name) ~}}
{{define 'graphql_type_package' (concat service.namespace '.graphql.type_resolver.' graphql_type.fqn) ~}}
{{define 'package'  (concat graphql_type_package '.' (lower-snake graphql_field.name)) ~}}
{{define 'model' graphql_type.data_model ~}}
{{define 'aggregates' graphql_field.referencing_graphql_type.data_model.aggregates ~}}
{{define 'context_type' graphql_field.context_type ~}}
{{define 'filter' fetcher.result_filter ~}}
package {{package}}

import org.springframework.stereotype.Component
import graphql.schema.DataFetchingEnvironment
import kotlinx.coroutines.reactor.mono
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono
import {{graphql_type_package}}.*
{{#if (not (eq graphql_type graphql_field.referencing_graphql_type)) ~}}
{{define 'ref_type' graphql_field.referencing_graphql_type ~}}
{{define 'graphql_type_package' (concat service.namespace '.graphql.type_resolver.' ref_type.fqn) ~}}
import {{graphql_type_package}}.*
{{/if}}

/**
 * The fetcher of the {{graphql_field.name}} of the {{graphql_type.name}}.
 */
@Component("{{graphql_field.fqn}}.fetcher")
class {{fetcher_class_name}}(
    val repository: {{repository_class_name}}
) {
    /**
     * Fetches the content of the {{graphql_field.name}} field.
     */
    fun fetch(environment: DataFetchingEnvironment): Mono<{{graphql_field.return_type}}> = mono {
            {{#if context_type ~}}
            val self: {{context_type}} = environment.getSource()
            {{/if}}
            val arguments = {{arguments_class_name}}.from(environment.arguments)
            repository.{{lower-camel graphql_field.name}}({{if context_type 'self, '}}arguments)
        }
        .map { records -> {{graphql_field.record_type}}.from(records{{if (not aggregates) ')}'}}
            {{#if aggregates ~}}
            .groupBy { mapOf(
                {{#each model.primary_keys as |pk| ~}}
                {{define 'pk_name' (lower-camel pk.name) ~}}
                "{{pk_name}}" to it["{{pk_name}}"],
                {{/each}}
            )}
            .map { (k, v) -> k + mapOf(
                {{#each aggregates as |aggregate| ~}}
                {{define 'aggregate_name' (lower-camel aggregate.name) ~}}
                "{{aggregate_name}}" to v.fold(mutableListOf<Map<String, Any?>>()) { acc, map -> acc.apply {
                    if (map.containsKey("{{aggregate_name}}")) add(map["{{aggregate_name}}"] as Map<String, Any?>)
                }}
                {{/each}}
            )}
            {{/if}}
        {{if aggregates ')}'}}
        {{#if filter ~}}
        .map { result ->
            {{#if (and context_type (contains filter 'self')) ~}}
            val self: {{record_class_name}} = environment.getSource()
            {{/if}}
            {{#if (and graphql_field.arguments (contains filter 'arguments')) ~}}
            val arguments = {{arguments_class_name}}.from(environment.arguments)
            {{/if}}
            {{shift fetcher.result_filter 12}}
        }
        {{/if}}
}
