{{define "base_package" (concat service.namespace '.graphql.type.' (lower-snake graphql_type.name)) ~}}
{{define "class_base_name" (upper-camel graphql_type.name) ~}}
{{define "resolver_class_name" (concat class_base_name 'Resolver') ~}}
{{define "record_class_name" (concat class_base_name 'Record') ~}}
{{define "default_query_name" (lower-camel graphql_type.default_query_name) ~}}
package {{base_package}}

import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.springframework.stereotype.Component
import graphql.schema.idl.RuntimeWiring
import graphql.schema.idl.TypeRuntimeWiring
import graphql.schema.DataFetchingEnvironment
import org.springframework.beans.factory.annotation.Value
import org.springframework.core.io.FileSystemResource
import reactor.core.publisher.Mono

/**
 * A reactive implementation of the {{graphql_type.name}} graphql type resolver.
 */
@Component
class {{resolver_class_name}}(
   @Value("\${graphql.static-data.{{hyphen graphql_type.name}}.data-file-path:data/{{hyphen class_base_name}}.json}")
   private val dataFilePath: String
) {
    private val allStaticRecords: List<{{record_class_name}}> by lazy {
        val data = mapper.readValue(
            FileSystemResource(dataFilePath).inputStream, object: TypeReference<List<Map<String, Any?>>>() {}
        )
        {{record_class_name}}.from(data)
    }

    fun {{default_query_name}}(context: DataFetchingEnvironment): Mono<List<{{record_class_name}}>> =
        Mono.just(allStaticRecords)

    fun registerFetcher(wiring: RuntimeWiring.Builder) = wiring.type(
        TypeRuntimeWiring.newTypeWiring("{{class_base_name}}")
        .dataFetcher("{{default_query_name}}") { env -> {{default_query_name}}(env).toFuture() }
    )

    companion object {
        val mapper = jacksonObjectMapper()
    }
}
