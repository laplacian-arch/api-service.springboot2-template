{{#define "repository_name"}}{{top_level.class_name}}Repository{{/define}}
{{#define "package"}}{{top_level.namespace}}.entity.{{top_level.identifier}}{{/define}}
package {{package}}
import kotlinx.coroutines.future.future
import kotlinx.coroutines.runBlocking
import org.springframework.stereotype.Component
import org.springframework.data.r2dbc.core.DatabaseClient
import java.util.concurrent.CompletableFuture

/**
 * An implementation of the {{repository_name}}.
 */
@Component
class {{repository_name}}Base(
    private val db: DatabaseClient
): {{repository_name}} {
{{#*inline "METHOD_DEFINITION_FOR_AN_ENTITY"}}
    {{define "plural_name" (plural entity.name) ~}}
    {{define "entity_class_name" (concat (upper-camel entity.name) 'Entity') ~}}
    {{define "loader_method_name" (concat 'load' (upper-camel plural_name)) ~}}
    {{define "fqn" entity.fqn ~}}
    {{#each data_accesses as |data_access| ~}}
    {{#if (eq data_access.entity.fqn fqn) ~}}
    {{define "method_name" (lower-camel data_access.name) ~}}
    override fun {{method_name}}(): CompletableFuture<{{data_access.type}}> =
        {{shift data_access.script_body 8}}
    {{/if}}
    {{/each}}

    override fun {{loader_method_name}}(): CompletableFuture<Set<{{entity_class_name}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{lower-snake entity.owned_by.name}}_{{lower-snake pk.name}},
          {{/each}}
          {{#each entity.primary_keys as |pk| ~}}
          {{lower-snake pk.name}}{{#unless @last}},{{/unless}}
          {{/each}}
        FROM
          {{lower-snake entity.name}}
        """
        .trimIndent())
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).toSet() }
        .toFuture()

    override fun {{loader_method_name}}(keys: Set<{{entity_class_name}}>): CompletableFuture<Set<{{entity_class_name}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{lower-snake entity.owned_by.name}}_{{lower-snake pk.name}},
          {{/each}}
          {{#each entity.stored_properties as |property| ~}}
          {{lower-snake property.name}}{{#unless @last}},{{/unless}}
          {{/each}}
        FROM
          {{lower-snake entity.name}}
        WHERE
        -- ${keys.mapIndexed{ index, _ -> """
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{define 'column_name' (concat (lower-snake entity.owned_by.name) '_' (lower-snake pk.name)) ~}}
          {{lower-snake entity.name}}.{{column_name}} = :{{lower-camel column_name}}${index}
        AND
          {{/each}}
          {{#each entity.primary_keys as |pk| ~}}
          {{lower-snake entity.name}}.{{lower-snake pk.name}} = :{{lower-camel pk.name}}${index}
          {{#unless @last}}
        AND
          {{/unless}}
          {{/each}}
        -- """}.joinToString("\nOR\n")}
        """.trimMargin())
        .let { sql ->
            keys.foldIndexed(sql){ index, acc, key ->
                acc
                {{#each entity.owner.primary_keys as |pk| ~}}
                {{define 'column_name' (concat (lower-snake entity.owned_by.name) '_' (lower-snake pk.name)) ~}}
                .bind("{{lower-camel column_name}}${index}", key.{{lower-camel column_name}})
                {{/each}}
                {{#each entity.primary_keys as |pk| ~}}
                .bind("{{lower-camel pk.name}}${index}", key.{{lower-camel pk.name}})
                {{/each}}
            }
        }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).toSet() }
        .toFuture()

    {{#each entity.stored_relationships as |r| ~}}
    {{#if r.multiple ~}}
    {{define "reference_entity" r.reference_entity ~}}
    {{define "reference_entity_class_name" (concat reference_entity.class_name 'Entity') ~}}
    {{define "relationship_name" reference_entity.owned_by.name ~}}
    {{define "loader_method_name" (concat 'load' (upper-camel r.name) 'Of' (upper-camel entity.name)) ~}}
    override fun {{loader_method_name}}(keys: Set<{{entity_class_name}}>): CompletableFuture<Map<{{entity_class_name}}, List<{{reference_entity_class_name}}>>> =
        db.execute(
        """
        SELECT
          {{#each entity.primary_keys as |pk| ~}}
          {{define 'derived_pk_name' (concat (lower-snake relationship_name) '_' (lower-snake pk.name)) ~}}
          {{derived_pk_name}} AS "{{lower-snake pk.name}}",
          {{derived_pk_name}} AS "{{lower-snake r.name}}.{{derived_pk_name}}",
          {{/each}}
          {{#each reference_entity.primary_keys as |pk| ~}}
          {{lower-snake pk.name}} AS "{{lower-snake r.name}}.{{lower-snake pk.name}}"{{#unless @last}},{{/unless}}
          {{/each}}
        FROM
          {{lower-snake reference_entity.name}}
        WHERE
        -- ${keys.mapIndexed{ index, _ -> """
          {{#each entity.primary_keys as |pk| ~}}
          {{#unless @first}}
        AND
          {{/unless}}
          {{lower-snake relationship_name}}_{{lower-snake pk.name}} = :{{lower-camel relationship_name}}{{upper-camel pk.name}}${index}
          {{/each}}
        -- """}.joinToString("\nOR\n")}
        """.trimMargin())
        .let { sql ->
            keys.foldIndexed(sql){ index, acc, key ->
                acc
                {{#each entity.primary_keys as |pk| ~}}
                {{define 'prop_name' (concat (lower-camel relationship_name) (upper-camel pk.name) '${index}') ~}}
                .bind("{{prop_name}}", key.{{pk.name}})
                {{/each}}
            }
        }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).map{ it to it.{{lower-camel r.name}} }.toMap() }
        .toFuture()
    {{/if}}
    {{/each}}
{{/inline}}
    {{#each top_level.aggregated_entities as |e| ~}}
    {{> METHOD_DEFINITION_FOR_AN_ENTITY entity=e ~}}
    {{/each}}
}
