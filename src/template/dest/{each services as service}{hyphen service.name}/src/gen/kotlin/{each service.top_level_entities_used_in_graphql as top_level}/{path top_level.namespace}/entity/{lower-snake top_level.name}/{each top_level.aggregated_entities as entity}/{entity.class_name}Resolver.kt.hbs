{{define "entity_class_name" (concat entity.class_name 'Entity') ~}}
{{define "repository_name" (concat top_level.class_name 'Repository') ~}}
{{define "package" (concat top_level.namespace '.entity.' (lower-snake top_level.name)) ~}}
{{define "lname" (lower-camel entity.name) ~}}
package {{package}}
{{#each entity.relating_top_level_entities as |relating_entity| ~}}
{{define "rel_namespace" (concat
  relating_entity.namespace '.entity.' (lower-underscore relating_entity.name)
)~}}
import {{rel_namespace}}.{{relating_entity.class_name}}Entity
import {{rel_namespace}}.{{relating_entity.class_name}}SearchInput
{{/each}}
import org.dataloader.DataLoader
import org.dataloader.DataLoaderRegistry
import org.springframework.stereotype.Component
import graphql.schema.idl.RuntimeWiring
import graphql.schema.idl.TypeRuntimeWiring
import graphql.schema.DataFetchingEnvironment
import java.util.concurrent.CompletableFuture

/**
 * An reactive implementation of the {{entity.name}} entity query resolver.
 */
@Component
class {{entity.class_name}}Resolver(
    private val {{lower-camel repository_name}}: {{repository_name}}
) {

    {{#each (filter entity.stored_properties '(not @it.primary_key)') as |property| ~}}
    /**
     * Loads the {{property.name}} of this {{entity.name}}.
     */
    fun {{property.property_name}}(self: {{entity_class_name}}, context: DataFetchingEnvironment): CompletableFuture<{{property.class_name}}> =
        context
        .getDataLoader<{{entity_class_name}}, {{entity_class_name}}>(BY_PK)
        .load(self)
        .thenApply<{{property.class_name}}>{ it.{{property.property_name}} }
    {{/each}}

    {{#each entity.stored_relationships as |relationship| ~}}
    {{define "ref_class_name" relationship.reference_entity.class_name}}
    {{define "ref_entity_class_name" (concat ref_class_name 'Entity')}}
    {{define "ref_type" (if relationship.multiple (printf 'List<%s>' ref_entity_class_name) ref_entity_class_name) ~}}
    /**
     * Loads the {{relationship.name}} of this {{entity.name}}.
     */
    fun {{relationship.property_name}}(self: {{entity_class_name}}, context: DataFetchingEnvironment): CompletableFuture<{{ref_type}}> =
        context
        .getDataLoader<Pair<{{ref_class_name}}SearchInput, {{entity_class_name}}>, {{ref_type}}>({{upper-underscore relationship.property_name}})
        .load({{ref_class_name}}SearchInput.from(context.arguments) to self)
        {{#if relationship.multiple}}
        .thenApply<{{ref_type}}>{ it ?: emptyList() }
        {{/if}}
    {{/each}}

    fun registerLoader(registry: DataLoaderRegistry) {
        registry.register(BY_PK, DataLoader.newMappedDataLoader<{{entity_class_name}}, {{entity_class_name}}> { keys ->
            {{lower-camel top_level.identifier}}Repository
            .load{{upper-camel (plural entity.identifier)}}(keys)
            .thenApply{ set -> set.map{ (it to it) }.toMap() }
        })
        {{#each entity.stored_relationships as |relationship| ~}}
        {{define "ref_entity" relationship.reference_entity ~}}
        {{define "ref_entity_name" (upper-camel ref_entity.name)}}
        {{define "ref_entity_class_name" (concat ref_entity_name 'Entity') ~}}
        {{define "result_type" (if relationship.multiple (concat 'List<' ref_entity_class_name '>') ref_entity_class_name) ~}}
        registry.register({{upper-snake relationship.property_name}}, DataLoader.newMappedDataLoader<Pair<{{ref_entity_name}}SearchInput, {{entity_class_name}}>, {{result_type}}> { entries ->
            val input = entries.fold(mutableMapOf<{{ref_entity_name}}SearchInput, MutableSet<{{entity_class_name}}>>()) { acc, ({{lower-camel ref_entity_name}}SearchInput, {{lname}}) ->
                val {{plural lname}} = acc.getOrPut({{lower-camel ref_entity_name}}SearchInput) { mutableSetOf<{{entity_class_name}}>() }
                {{plural lname}}.add({{lname}})
                acc
            }
            {{lname}}Repository
            .load{{upper-camel relationship.property_name}}Of{{entity.class_name}}(input)
        })
        {{/each}}
    }

    fun registerFetcher(wiring: RuntimeWiring.Builder) = wiring.type(
        {{define "property_names" (concat
            (map (filter entity.stored_properties '(not @it.primary_key)') '@it.name')
            (map entity.stored_relationships '@it.name')
        ) ~}}
        TypeRuntimeWiring.newTypeWiring("{{upper-camel entity.name}}")
        {{#each property_names as |property_name| ~}}
        .dataFetcher("{{lower-camel property_name}}") { env ->
            val key = env.getSource() as {{entity_class_name}}
            {{lower-camel property_name}}(key, env)
        }
        {{/each}}
    )

    companion object {
        const val BY_PK = "{{lname}}_byPK"
        {{#each entity.stored_relationships as |relationship| ~}}
        const val {{upper-underscore relationship.property_name}} = "{{lname}}_{{relationship.property_name}}"
        {{/each}}
    }
}

