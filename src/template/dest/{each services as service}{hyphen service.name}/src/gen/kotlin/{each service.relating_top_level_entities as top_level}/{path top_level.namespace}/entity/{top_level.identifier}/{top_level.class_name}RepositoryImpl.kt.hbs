{{#define "repository_name"}}{{top_level.class_name}}Repository{{/define}}
{{#define "package"}}{{top_level.namespace}}.entity.{{lower-snake top_level.name}}{{/define}}
package {{package}}
import kotlinx.coroutines.future.future
import kotlinx.coroutines.runBlocking
import org.springframework.stereotype.Component
import org.springframework.data.r2dbc.core.DatabaseClient
import java.util.concurrent.CompletableFuture
import laplacian.tutorial.entity.RepositoryBase
{{#each top_level.relating_top_level_entities as |other| ~}}
import {{other.namespace}}.entity.{{lower-snake other.name}}.{{upper-camel other.name}}Entity
{{/each}}

/**
 * An implementation of the {{repository_name}}.
 */
@Component
class {{repository_name}}Impl(
    private val db: DatabaseClient
): RepositoryBase(db), {{repository_name}} {
{{#*inline "METHOD_DEFINITION_FOR_AN_ENTITY"}}
    {{define "plural_name" (plural entity.name) ~}}
    {{define "entity_class_name" (concat (upper-camel entity.name) 'Entity') ~}}
    {{define "search_input_class_name" (concat (upper-camel entity.name) 'SearchInput') ~}}
    {{define "loader_method_name" (concat 'load' (upper-camel plural_name)) ~}}
    {{define "finder_method_name" (concat 'find' (upper-camel plural_name)) ~}}
    {{define "fqn" entity.fqn ~}}
    {{#each data_accesses as |data_access| ~}}
    {{#if (eq data_access.entity.fqn fqn) ~}}
    {{define "method_name" (lower-camel data_access.name) ~}}
    override fun {{method_name}}(): CompletableFuture<{{data_access.type}}> =
        {{shift data_access.script_body 8}}
    {{/if}}
    {{/each}}

    /**
     * Loads {{plural_name}}.
     */
    override fun {{finder_method_name}}(input: {{search_input_class_name}}): CompletableFuture<Set<{{entity_class_name}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{lower-snake entity.owned_by.name}}_{{lower-snake pk.name}},
          {{/each}}
          {{#each entity.primary_keys as |pk| ~}}
          {{lower-snake pk.name}}{{#unless @last}},{{/unless}}
          {{/each}}
        FROM
          {{table-name entity.name}}
        --${if (input.isEmpty()) "" else """
        WHERE
          {{#each entity.stored_properties as |p| ~}}
          {{define "prop_name" (lower-camel p.name) ~}}
          {{define "col_name" (column-name p.name) ~}}
          {{define "table_name" (table-name entity.name) ~}}
          {{#if (eq p.type 'string') ~}}
          --${if (input.{{prop_name}}.equalsTo.isEmpty()) "" else """
          (
          --${input.{{prop_name}}.equalsTo.mapIndexed { index, _ -> """
            {{table_name}}.{{col_name}} = :{{prop_name}}_equalsTo_${index}
          --"""}.joinToString("\nOR\n")}
          ) AND
          --"""}
          --${if (input.{{prop_name}}.startsWith.isEmpty()) "" else """
          (
          --${input.{{prop_name}}.startsWith.mapIndexed { index, _ -> """
            {{table_name}}.{{col_name}} LIKE :{{prop_name}}_startsWith_${index} ESCAPE '\'
          --"""}.joinToString("\nOR\n")}
          ) AND
          --"""}
          --${if (input.{{prop_name}}.endsWith.isEmpty()) "" else """
          (
          --${input.{{prop_name}}.endsWith.mapIndexed { index, _ -> """
            {{table_name}}.{{col_name}} LIKE :{{prop_name}}_endsWith_${index} ESCAPE '\'
          --"""}.joinToString("\nOR\n")}
          ) AND
          --"""}
          --${if (input.{{prop_name}}.contains.isEmpty()) "" else """
          (
          --${input.{{prop_name}}.contains.mapIndexed { index, _ -> """
            {{table_name}}.{{col_name}} LIKE :{{prop_name}}_contains${index} ESCAPE '\'
          --"""}.joinToString("\nOR\n")}
          ) AND
          --"""}
          {{/if}}
          {{#if (eq p.type 'number') ~}}
          -- ${if (input.{{prop_name}}.equalsTo.isEmpty()) "" else """
          (
          -- ${input.{{prop_name}}.equalsTo.mapIndexed { index, _ -> """
            {{table_name}}.{{col_name}} = :{{prop_name}}_equalsTo_${index}
          --"""}.joinToString("\nOR\n")}
          ) AND
          --"""}
          -- ${if (input.{{prop_name}}.greaterThan == null) "" else """
          (
            {{table_name}}.{{col_name}} >= :{{prop_name}}_greaterThan
          ) AND
          --"""}
          -- ${if (input.{{prop_name}}.lessThan == null) "" else """
          (
            {{table_name}}.{{col_name}} <= :{{prop_name}}_lessThan
          ) AND
          --"""}
          {{/if}}
          {{/each}}
        --"""}
        """.trimMargin().replace("""AND(\s*--\s*)*$""".toRegex(), ""))
        .let {
            var sql = it
            {{#each entity.stored_properties as |p| ~}}
            {{#if (eq p.type 'string') ~}}
            {{define "prop_name" (lower-camel p.name) ~}}
            sql = input.{{prop_name}}.equalsTo.foldIndexed(sql){ index, acc, value ->
                acc.bind("{{prop_name}}_equalsTo_${index}", value)
            }
            sql = input.{{prop_name}}.startsWith.foldIndexed(sql){ index, acc, value ->
                acc.bind("{{prop_name}}_startsWith_${index}", escapeWildcard(value) + "%")
            }
            sql = input.{{prop_name}}.endsWith.foldIndexed(sql){ index, acc, value ->
                acc.bind("{{prop_name}}_endsWith_${index}", "%" + escapeWildcard(value))
            }
            sql = input.{{prop_name}}.contains.foldIndexed(sql){ index, acc, value ->
                acc.bind("{{prop_name}}_contains_${index}", "%" + escapeWildcard(value) + "%")
            }
            {{/if}}
            {{#if (eq p.type 'number') ~}}
            {{define "prop_name" (lower-camel p.name) ~}}
            sql = input.{{prop_name}}.equalsTo.foldIndexed(sql){ index, acc, value ->
                acc.bind("{{prop_name}}_equalsTo_${index}", value)
            }
            if (input.{{prop_name}}.greaterThan != null) {
                sql = sql.bind("{{prop_name}}_greaterThan", input.{{prop_name}}.greaterThan)
            }
            if (input.{{prop_name}}.lessThan != null) {
                sql = sql.bind("{{prop_name}}_lessThan", input.{{prop_name}}.lessThan)
            }
            {{/if}}
            {{/each}}
            sql
        }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).toSet() }
        .toFuture()

    /**
     * Loads {{plural_name}} having the given keys.
     */
    override fun {{loader_method_name}}(keys: Set<{{entity_class_name}}>): CompletableFuture<Set<{{entity_class_name}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{column-name entity.owned_by.name}}_{{column-name pk.name}},
          {{/each}}
          {{#each entity.stored_properties as |property| ~}}
          {{column-name property.name}}{{#unless @last}},{{/unless}}
          {{/each}}
        FROM
          {{table-name entity.name}}
        WHERE
        -- ${keys.mapIndexed{ index, _ -> """
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{define 'col_name' (column-name (concat entity.owned_by.name ' ' pk.name)) ~}}
        {{#unless @first ~}}
        AND
        {{/unless}}
          {{table-name entity.name}}.{{col_name}} = :{{lower-camel col_name}}${index}
          {{/each}}
          {{#each entity.primary_keys as |pk| ~}}
        {{#unless (and (not entity.owner) @first) ~}}
        AND
        {{/unless}}
          {{table-name entity.name}}.{{lower-snake pk.name}} = :{{lower-camel pk.name}}${index}
          {{/each}}
        -- """}.joinToString("\nOR\n")}
        """.trimMargin())
        .let { sql ->
            keys.foldIndexed(sql){ index, acc, key ->
                acc
                {{#each entity.owner.primary_keys as |pk| ~}}
                {{define 'col_name' (column-name (concat entity.owned_by.name ' ' pk.name)) ~}}
                .bind("{{lower-camel col_name}}${index}", key.{{lower-camel col_name}})
                {{/each}}
                {{#each entity.primary_keys as |pk| ~}}
                .bind("{{lower-camel pk.name}}${index}", key.{{lower-camel pk.name}})
                {{/each}}
            }
        }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).toSet() }
        .toFuture()

    {{#each entity.stored_relationships as |r| ~}}
    {{define "reference_entity" r.reference_entity ~}}
    {{define "reference_entity_class_name" (concat reference_entity.class_name 'Entity') ~}}
    {{define "result_type" (if r.multiple
        (concat 'List<' reference_entity_class_name '>')
        reference_entity_class_name
    ) ~}}
    {{define "loader_method_name" (concat 'load' (upper-camel r.name) 'Of' (upper-camel entity.name)) ~}}
    {{define "derived_key_prefix" reference_entity.owned_by.name ~}}
    /**
     * Loads {{r.name}} of this {{entity.name}}.
     */
    override fun {{loader_method_name}}(keys: Set<{{entity_class_name}}>): CompletableFuture<Map<{{entity_class_name}}, {{result_type}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.primary_keys as |pk| ~}}
          {{define 'is_last' (and @last (not reference_entity.primary_keys)) ~}}
          {{#if r.aggregate ~}}
          {{define 'derived_pk_name' (column-name (concat derived_key_prefix '_' pk.name)) ~}}
          {{table-name entity.name}}.{{column-name pk.name}} AS "{{column-name pk.name}}",
          {{table-name reference_entity.name}}.{{derived_pk_name}} AS "{{column-name r.name}}.{{derived_pk_name}}"{{if is_last '' ','}}
          {{else}}
          {{table-name entity.name}}.{{column-name pk.name}} AS "{{column-name pk.name}}"{{if is_last '' ','}}
          {{/if}}
          {{/each}}
          {{#each reference_entity.primary_keys as |pk| ~}}
          {{table-name reference_entity.name}}.{{column-name pk.name}} AS "{{column-name r.name}}.{{column-name pk.name}}"{{if @last '' ','}}
          {{/each}}
        FROM
          {{table-name entity.name}},
          {{table-name reference_entity.name}}
        WHERE
        {{#if r.aggregate ~}}
          {{#each entity.primary_keys as |pk| ~}}
        {{if @first '' 'AND'}}
          {{table-name entity.name}}.{{column-name pk.name}} = {{table-name reference_entity.name}}.{{column-name (concat derived_key_prefix ' ' pk.name)}}
          {{/each}}
        {{else}}
          {{#each r.mappings as |mapping| ~}}
        {{if @first '' 'AND'}}
          {{table-name entity.name}}.{{column-name mapping.from}} = {{table-name reference_entity.name}}.{{column-name mapping.to}}
          {{/each}}
        {{/if}}
        AND (
        -- ${keys.mapIndexed{ index, _ -> """
        {{#if r.aggregate ~}}
          {{#each entity.primary_keys as |pk| ~}}
        {{#unless @first}}
        AND
        {{/unless}}
          {{table-name reference_entity.name}}.{{column-name (concat derived_key_prefix ' ' pk.name)}} = :{{lower-camel derived_key_prefix}}{{upper-camel pk.name}}${index}
          {{/each}}
        {{else}}
          {{#each r.mappings as |mapping| ~}}
        {{#unless @first}}
        AND
        {{/unless}}
          {{table-name reference_entity.name}}.{{column-name mapping.to}} = :{{lower-camel mapping.from}}${index}
          {{/each}}
        {{/if}}
        -- """}.joinToString("\nOR\n")}
        )
        """.trimMargin())
        .let { sql ->
            keys.foldIndexed(sql){ index, acc, key ->
                acc
                {{#if r.aggregate ~}}
                {{#each entity.primary_keys as |pk| ~}}
                {{define 'prop_name' (concat (lower-camel derived_key_prefix) (upper-camel pk.name) '${index}') ~}}
                .bind("{{prop_name}}", key.{{lower-camel pk.name}})
                {{/each}}
                {{else}}
                {{#each r.mappings as |mapping|}}
                .bind("{{lower-camel mapping.from}}${index}", key.{{lower-camel mapping.from}})
                {{/each}}
                {{/if}}
            }
        }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).map{ it to it.{{lower-camel r.name}} }.toMap() }
        .toFuture()
    {{/each}}
{{/inline}}
    {{#each top_level.aggregated_entities as |e| ~}}
    {{> METHOD_DEFINITION_FOR_AN_ENTITY entity=e ~}}
    {{/each}}
}
