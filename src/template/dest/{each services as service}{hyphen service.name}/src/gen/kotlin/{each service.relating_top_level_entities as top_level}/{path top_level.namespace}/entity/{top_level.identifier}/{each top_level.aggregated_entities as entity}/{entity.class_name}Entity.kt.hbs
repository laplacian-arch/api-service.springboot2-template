{{define "entity_class_name" (concat entity.class_name 'Entity') ~}}
{{define "package" (concat top_level.namespace '.entity.' (lower-snake top_level.name)) ~}}
package {{package}}
{{#each entity.relating_top_level_entities as |e| ~}}
{{define "e_package" (concat e.namespace '.entity.' (lower-snake e.name)) ~}}
{{#unless (eq e_package package) ~}}
import {{e_package}}.{{e.class_name}}Entity
{{/unless}}
{{/each}}
import java.util.*

/**
 * {{trim entity.description}}
 */
class {{entity_class_name}} {
    {{#each entity.inherited_from as |inheritance| ~}}
    {{#each inheritance.reference_entity.primary_keys as |pk| ~}}
    /**
     * {{trim pk.description}}
     */
    {{define 'prop_name' (lower-camel (concat inheritance.name ' ' pk.name)) ~}}
    {{#if (or (eq pk.type 'boolean') (eq pk.type 'number')) ~}}
    private var _{{prop_name}}: {{pk.class_name}}? = null
    var {{prop_name}}: {{pk.class_name}}
        get() = _{{prop_name}}!!
        set(v) { _{{prop_name}} = v }
    {{else}}
    lateinit var {{prop_name}}: {{pk.class_name}}
    {{/if}}
    {{/each}}
    {{/each}}
    {{#each entity.stored_properties as |p| ~}}
    /**
     * {{trim p.description}}
     */
    {{#if p.optional ~}}
    {{define 'initial_value' (case
      p.default_value      p.default_value
      (eq p.nullable)      'null'
      (eq p.type "number") '0'
      (eq p.type "string") '""'
      ''
    ) ~}}
    var {{p.property_name}}: {{p.class_name}} = {{initial_value}}
    {{else}}
    {{#if (or (eq p.type 'boolean') (eq p.type 'number')) ~}}
    private var _{{p.property_name}}: {{p.class_name}}? = null
    var {{p.property_name}}: {{p.class_name}}
        get() = _{{p.property_name}}!!
        set(v) { _{{p.property_name}} = v }
    {{else}}
    lateinit var {{p.property_name}}: {{p.class_name}}
    {{/if}}
    {{/if}}
    {{/each}}

    {{#each entity.stored_relationships as |r|}}
    {{define "reference_entity_class_name" (upper-camel (concat r.reference_entity.name ' Entity')) ~}}
    {{#if r.multiple}}
    /**
     * {{trim r.description}}
     */
    lateinit var {{r.property_name}}: List<{{reference_entity_class_name}}>
    {{else}}
    /**
     * {{trim r.description}}
     */
    var {{r.property_name}}: {{reference_entity_class_name}}
        {{#if r.inherited}}@JsonIgnore{{/if}}
        get() = _{{r.property_name}} ?: {{reference_entity_class_name}}().also {
            {{#if r.inherited}}
            {{#each r.reference_entity.primary_keys as |key|}}
            it.{{lower-camel key.identifier}} = {{lower-camel r.property_name}}{{upper-camel key.identifier}}{{#unless @last}} &&{{/unless}}
            {{/each}}
            {{else}}
            {{#each r.mappings as |m|}}
            it.{{lower-camel m.to}} = {{lower-camel m.from}}{{#unless @last}} &&{{/unless}}
            {{/each}}
            {{/if}}
        }
        set(value) { _{{r.property_name}} = value }
    private var _{{r.property_name}}: {{reference_entity_class_name}}? = null
    {{/if}}
    {{/each}}

    override fun equals(other: Any?): Boolean =
        (other === this) ||
        (other != null) &&
        (other is {{entity_class_name}}) &&
        {{#each entity.owner.primary_keys as |pk| ~}}
        {{#define "prop_name"}}{{lower-camel entity.owned_by.name}}{{upper-camel pk.name}}{{/define}}
        Objects.equals(this.{{prop_name}}, other.{{prop_name}}){{#unless (and @last (not entity.primary_keys))}} &&{{/unless}}
        {{/each}}
        {{#each entity.primary_keys as |pk| ~}}
        Objects.equals(this.{{lower-camel pk.name}}, other.{{lower-camel pk.name}}){{#unless @last}} &&{{/unless}}
        {{/each}}

    override fun hashCode(): Int = Objects.hash(
        {{#each entity.owner.primary_keys as |pk| ~}}
        this.{{lower-camel entity.owned_by.name}}{{upper-camel pk.name}}{{#unless (and @last (not entity.primary_keys))}},{{/unless}}
        {{/each}}
        {{#each entity.primary_keys as |pk| ~}}
        this.{{lower-camel pk.name}}{{#unless @last}},{{/unless}}
        {{/each}}
    )

    override fun toString(): String = "{{entity_class_name}}(" +
        {{#each entity.owner.primary_keys as |pk| ~}}
        {{define "derived_key" (lower-camel (concat entity.owned_by.name ' ' pk.name)) ~}}
        "{{derived_key}}: ${{derived_key}}{{#if (and @last (not entity.primary_keys))}})"{{else}}, " +{{/if}}
        {{/each}}
        {{#each entity.primary_keys as |pk| ~}}
        "{{lower-camel pk.name}}: ${{lower-camel pk.name}}{{#if @last}})"{{else}}, " +{{/if}}
        {{/each}}

    {{define "properties" (concat entity.owner.primary_keys entity.stored_properties)}}
    companion object {
        fun fromRecord(
            record: Record,
            prefix: String = ""
        ): {{entity_class_name}} = {{entity_class_name}}().apply {
            {{#if (any properties '(eq @it.type "string")') ~}}
            val nonNullString = {key: String, value: Any? ->
                value?.toString() ?: throw IllegalArgumentException(
                    "$key must not be null: $record"
                )
            }
            {{/if}}
            {{#if (any properties '(eq @it.type "number")') ~}}
            val nonNullInteger = {key: String, value: Any? ->
                if (value is Int)
                  value
                else
                  value?.toString()?.toInt() ?: throw IllegalArgumentException(
                    "$key must not be null: $record"
                  )
            }
            {{/if}}
            {{#if (any properties '(eq @it.type "boolean")') ~}}
            val nonNullBoolean = {key: String, value: Any? ->
                nonNullInteger(key, value) != 0
            }
            {{/if}}
            record.forEach { k, v ->
                when(k) {
                    {{#each entity.owner.primary_keys as |pk| ~}}
                    {{define 'derived_pk_name' (printf '%s_%s' entity.owned_by.name pk.name) ~}}
                    {{define 'converter' (case
                      (eq pk.type "string") "nonNullString(k, v)"
                      (eq pk.type "number") "nonNullInteger(k, v)"
                      (eq pk.type "boolean") "nonNullBoolean(k, v)"
                    ) ~}}
                    prefix + "{{lower-snake derived_pk_name}}" -> {{lower-camel derived_pk_name}} = {{converter}}
                    {{/each}}
                    {{#each entity.stored_properties as |p| ~}}
                    {{define 'converter' (case
                      (eq p.type "string") "nonNullString(k, v)"
                      (eq p.type "number") "nonNullInteger(k, v)"
                      (eq p.type "boolean") "nonNullBoolean(k, v)"
                    ) ~}}
                    prefix + "{{lower-snake p.property_name}}" -> {{lower-camel p.property_name}} = {{converter}}
                    {{/each}}
                }
            }
        }

        fun <T> fromRecordsGrouping(
            records: Records,
            groupBy: (Record) -> T
        ): Map<T, List<{{entity_class_name}}>> {
            if (records.isEmpty()) return emptyMap()
            return records.fold(mutableMapOf<T, MutableList<Record>>()) { acc, record ->
                val key = groupBy(record)
                acc.getOrPut(key) { mutableListOf<Record>() }
                   .add(record)
                acc
            }.mapValues { (_, records) ->
                fromRecords(records)
            }
        }

        {{#unless entity.stored_relationships ~}}
        fun fromRecords(
            records: Records,
            prefix: String = ""
        ): List<{{entity_class_name}}> {
            return records.map { fromRecord(it, prefix) }
        }

        {{else}}
        fun fromRecords(
            records: Records,
            prefix: String = ""
        ): List<{{entity_class_name}}> {
            if (records.isEmpty()) return emptyList()
            {{#each entity.stored_relationships as |relationship| ~}}
            val nesting{{upper-camel relationship.name}} = records.first().keys.any{ it.startsWith("{{lower-camel relationship.name}}.") }
            {{/each}}
            return records.fold(mutableMapOf<{{entity_class_name}}, MutableList<Record>>()) { acc, record ->
                val key = {{entity_class_name}}.fromRecord(record, prefix)
                acc.also {
                    it.getOrPut(key) { mutableListOf<Record>() }
                      .add(record)
                }
            }.map { ({{lower-camel entity.name}}, records) ->
                {{#each entity.stored_relationships as |relationship| ~}}
                if (nesting{{upper-camel relationship.name}}) {
                    {{lower-camel entity.name}}.{{lower-camel relationship.name}} = {{relationship.reference_entity.class_name}}Entity.fromRecords(records, "{{lower-snake relationship.name}}."){{#unless relationship.multiple}}.first(){{/unless}}
                }
                {{/each}}
                {{lower-camel entity.name}}
            }
        }
        {{/unless}}
    }
}
