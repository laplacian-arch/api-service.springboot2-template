{{define "class_base_name" (upper-camel search_index.name) ~}}
{{define 'index_fields' search_index.document_model.stored_properties ~}}
package {{service.namespace}}.search.{{lower-snake search_index.name}}

import org.springframework.stereotype.Component
import org.springframework.data.elasticsearch.core.ReactiveElasticsearchOperations
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder
import org.springframework.data.elasticsearch.core.mapping.IndexCoordinates

import org.elasticsearch.index.query.QueryBuilders
import org.elasticsearch.search.aggregations.AggregationBuilders
import org.elasticsearch.search.aggregations.Aggregations
import org.elasticsearch.search.aggregations.bucket.terms.Terms
import org.elasticsearch.search.aggregations.metrics.Sum
import org.elasticsearch.search.aggregations.bucket.range.ParsedDateRange
import org.elasticsearch.search.aggregations.PipelineAggregatorBuilders
import org.elasticsearch.script.Script

import java.util.concurrent.CompletableFuture

@Component
class {{class_base_name}}SearcherImpl(
    private val searcher: ReactiveElasticsearchOperations
): {{class_base_name}}Searcher {

    companion object {
        const val INDEX_NAME = "{{lower-snake search_index.name}}"
    }

    override fun find{{plural class_base_name}}(
        input: {{class_base_name}}SearchInput
    ): CompletableFuture<List<{{class_base_name}}Document>> {
        val query = NativeSearchQueryBuilder()
        {{#each index_fields as |property| ~}}
        {{define 'prop_name' (lower-camel property.name) ~}}
        {{#if (eq property.type 'string') ~}}
        if (!input.{{prop_name}}.isEmpty()) {
            query.withQuery(QueryBuilders.matchQuery("{{prop_name}}", input.{{prop_name}}))
        }
        {{/if}}
        {{#if (eq property.type 'number') ~}}
        if (!input.{{prop_name}}.equalsTo.isEmpty()) {
            query.withQuery(QueryBuilders.termsQuery("{{prop_name}}", input.{{prop_name}}.equalsTo))
        }
        if (input.{{prop_name}}.inRangeFrom != null) {
            query.withQuery(QueryBuilders.rangeQuery("{{prop_name}}").from(input.{{prop_name}}.inRangeFrom))
        }
        if (input.{{prop_name}}.inRangeTo != null) {
            query.withQuery(QueryBuilders.rangeQuery("{{prop_name}}").to(input.{{prop_name}}.inRangeTo))
        }
        {{/if}}
        {{/each}}
        return searcher.search(
            query.build(),
            {{class_base_name}}Document::class.java,
            IndexCoordinates.of(INDEX_NAME),
        )
        .map{ it.content }
        .collectList()
        .toFuture()
    }
    {{#each search_index.queries as |query| ~}}
    {{define 'class_base_name' (upper-camel query.name) ~}}
    override fun {{lower-camel class_base_name}}(
        input: {{class_base_name}}Input
    ): CompletableFuture<List<{{class_base_name}}Data>> {
        {{#each query.parameters as |parameter| ~}}
        {{define 'param_name' (lower-camel parameter.name) ~}}
        val {{param_name}} = input.{{param_name}}
        {{/each}}
        val query = NativeSearchQueryBuilder()
        {{#if query.predicate ~}}
        .withQuery(
            {{#*inline 'QUERY_PREDICATE'}}
            {{define 'predicate_type' PREDICATE.type ~}}
            {{#if (eq predicate_type 'term')}}
            QueryBuilders.termQuery("{{PREDICATE.field}}", {{dquote PREDICATE.value}})
            {{/if}}
            {{#if (eq predicate_type 'bool')}}
            QueryBuilders.boolQuery()
            {{#each PREDICATE.must as |predicate| ~}}
            .must(
                {{#shift width=4}}
                {{> QUERY_PREDICATE PREDICATE=predicate }}
                {{/shift}}
            )
            {{/each}}
            {{#each PREDICATE.must_not as |predicate| ~}}
            .mustNot(
                {{#shift width=4}}
                {{> QUERY_PREDICATE PREDICATE=predicate }}
                {{/shift}}
            )
            {{/each}}
            {{#each PREDICATE.should as |predicate| ~}}
            .should(
                {{#shift width=4}}
                {{> QUERY_PREDICATE PREDICATE=predicate }}
                {{/shift}}
            )
            {{/each}}
            {{#each PREDICATE.filter as |predicate| ~}}
            .filter(
                {{#shift width=4}}
                {{> QUERY_PREDICATE PREDICATE=predicate }}
                {{/shift}}
            )
            {{/each}}
            {{/if}}
            {{/inline}}
            {{> QUERY_PREDICATE PREDICATE=query.predicate }}
        )
        {{/if}}
        {{#if query.aggregates ~}}
        {{#each query.aggregates as |aggregate| ~}}
        .addAggregation(
            {{#*inline "AGGREGATION"}}
            {{define 'aggregate_type' AGGREGATE.aggregation_type ~}}
            {{define 'builder_factory_class' (case
              (eq aggregate_type 'bucket_script') 'PipelineAggregatorBuilders'
              'AggregationBuilders'
            ) ~}}
            {{builder_factory_class}}
            {{#if (eq aggregate_type 'filter') ~}}
            .filter(
                "{{AGGREGATE.name}}",
                {{#shift width=4 }}
                {{> QUERY_PREDICATE PREDICATE=AGGREGATE.predicate }}
                {{/shift}}
            )
            {{else if (eq aggregate_type 'bucket_script')}}
            .bucketScript(
                "{{AGGREGATE.name}}", mapOf(
                    {{#each AGGREGATE.buckets_path as |bucket| ~}}
                    "{{bucket.name}}" to "{{bucket.path}}",
                    {{/each}}
                ), Script({{dquote AGGREGATE.script}})
            )
            {{else}}
            .{{lower-camel aggregate_type}}("{{AGGREGATE.name}}")
            {{/if}}
            {{#if AGGREGATE.field ~}}
            .field("{{AGGREGATE.field}}")
            {{/if}}
            {{#each AGGREGATE.fields as |field| ~}}
            .field("{{field.name}}")
            {{/each}}
            {{#if (eq aggregate_type 'date_range')}}
            {{#each AGGREGATE.ranges as |range| ~}}
            {{#if (and range.from range.to) ~}}
            {{define 'key' (if range.key range.key (concat range.from '~' range.to)) ~}}
            .addRange("{{key}}", {{dquote range.from}}, {{dquote range.to}})
            {{else if range.from ~}}
            .addUnboundedFrom({{key}}, {{dquote range.from}})
            {{else if range.to ~}}
            .addUnboundedTo({{key}}, {{dquote range.to}})
            {{/if}}
            {{/each}}
            {{/if}}
            {{#each AGGREGATE.sub_aggregates as |sub_aggregate|}}
            .subAggregation(
                {{#shift width=4}}
                {{> AGGREGATION AGGREGATE=sub_aggregate }}
                {{/shift}}
            )
            {{/each}}
            {{/inline}}
            {{> AGGREGATION AGGREGATE=aggregate }}
        )
        {{/each}}
        val result = searcher.aggregate(query.build(),
            {{class_base_name}}Data::class.java,
            IndexCoordinates.of(INDEX_NAME),
        )

        val countByWord = { aggregations: Aggregations ->
            val sum = aggregations.get("count") as Sum
            sum.value.toInt()
        }
        val wordsInDateRange = { aggregations: Aggregations ->
            val terms = aggregations.get("word") as Terms
            terms.buckets.map { it.keyAsString to it.aggregations }
        }

        return result.filter{it.name == "date_range@date"}.next().map{
            val perDateRangeAggregations = (it as ParsedDateRange).buckets.first().aggregations
            wordsInDateRange(perDateRangeAggregations).map {
                val word = it.first
                val perWordAggregations = it.second
                TrendingWordsRankingData(
                    word = word,
                    count = countByWord(perWordAggregations),
                )
            }
        }.toFuture()
        {{/if}}
    }
    {{/each}}
}