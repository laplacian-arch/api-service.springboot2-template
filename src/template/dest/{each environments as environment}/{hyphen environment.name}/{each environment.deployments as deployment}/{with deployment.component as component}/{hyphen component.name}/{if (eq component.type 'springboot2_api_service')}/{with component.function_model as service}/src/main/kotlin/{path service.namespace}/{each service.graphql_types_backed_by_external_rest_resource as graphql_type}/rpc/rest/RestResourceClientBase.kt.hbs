{{define "package" (concat service.namespace '.rpc.rest') ~}}
package {{package}}

import org.springframework.web.reactive.function.client.WebClient
import org.springframework.web.reactive.function.client.ExchangeStrategies
import org.springframework.web.reactive.function.client.ClientResponse
import org.springframework.web.util.UriBuilder
import org.springframework.http.HttpHeaders
import org.springframework.http.MediaType
import org.springframework.cache.Cache
import reactor.core.publisher.Signal
import reactor.core.publisher.Mono
import reactor.cache.CacheMono
import graphql.GraphQLContext
import com.fasterxml.jackson.module.kotlin.*
import java.nio.charset.Charset
import org.slf4j.*

open class RestResourceClientBase {

    fun queryParam(uri: UriBuilder, key: String, value: String) =
        if (value.isEmpty()) uri else uri.queryParam(key, value)

    fun queryParams(uri: UriBuilder, key: String, valuesJson: String): UriBuilder {
        val values = jacksonObjectMapper().readValue<List<String>>(valuesJson)
        return if (values.isEmpty()) uri else values.fold(uri) { acc, each ->
            acc.queryParam(key, each)
        }
    }

    fun JSON(obj:Any?) = jacksonObjectMapper().writeValueAsString(obj)

    fun client(baseUrl: String): WebClient {
        return WebClient
        .builder()
        .exchangeStrategies(
            ExchangeStrategies
            .builder()
            .codecs { it.defaultCodecs().maxInMemorySize(10 * 1024 * 1024) }
            .build()
        )
        .baseUrl(baseUrl)
        .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
        .build()
    }

    fun <IN, RES> withCache(cache: Cache, operation:(IN) -> Mono<RES>): (IN) -> Mono<RES> = { input: IN ->
        CacheMono
        .lookup<IN, RES>({ key  ->
            Mono
            .justOrEmpty(cache.get(key as Any)?.get() as? RES)
            .map{ value -> Signal.next(value) }
        }, input)
        .onCacheMissResume(
            Mono
            .fromRunnable<Unit>{ log.info("Cache ${cache.name} missed. Key: ${input}") }
            .then(operation(input))
        )
        .andWriteWith { key, value ->
            Mono.fromRunnable{
                log.info("Writing a record on the cache ${cache.name}. Key: ${input}")
                cache.put(key as Any, value.get())
            }
        }
    }

    fun commonRequestSettings(req: WebClient.RequestBodySpec, context: GraphQLContext): WebClient.RequestBodySpec {
        return req
            .accept(MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML)
            .acceptCharset(Charset.forName("UTF-8"))
            .cookies { cookies ->
                val currentCookies = context.getOrDefault(httpCookiesContextKey, mapOf<String, List<String>>())
                currentCookies.forEach { cookie ->
                    cookies[cookie.key] = cookie.value
                }
            }
    }

    fun handleResponseCookies(response: ClientResponse, context: GraphQLContext) {
        val responseCookies = response.cookies().map{ (key, values) -> key to values.map{ it.value } }.toMap()
        if (responseCookies.isNotEmpty()) {
            val storedCookie = context.getOrDefault(httpCookiesContextKey, mapOf<String, List<String>>())
            context.put(httpCookiesContextKey, storedCookie + responseCookies)
        }
    }

    protected val httpCookiesContextKey = this.javaClass.name + "_http_cookies"
    protected val log: Logger = LoggerFactory.getLogger(this.javaClass)
}