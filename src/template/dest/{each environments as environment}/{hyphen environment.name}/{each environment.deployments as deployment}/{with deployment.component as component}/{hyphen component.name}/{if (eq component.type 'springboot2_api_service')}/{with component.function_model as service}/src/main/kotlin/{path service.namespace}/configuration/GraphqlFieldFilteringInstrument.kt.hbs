package {{service.namespace}}.configuration

import graphql.execution.instrumentation.SimpleInstrumentation
import graphql.execution.instrumentation.parameters.InstrumentationFieldFetchParameters
import graphql.schema.*
import org.slf4j.LoggerFactory
import java.util.regex.Pattern

class GraphqlFieldFilteringInstrument(
    private val ignoredFieldsPatterns: String
): SimpleInstrumentation() {

    private val compiledIgnoredFieldsPatterns: List<Pattern> = ignoredFieldsPatterns
        .split(",")
        .fold(mutableListOf<Pattern>()) { list, pattern ->
            list.add(Pattern.compile(pattern))
            list
        }

    private fun shouldIgnore(type: String, field: String): Boolean {
        val fqn = "${type}.${field}"
        val shouldBeIgnored = compiledIgnoredFieldsPatterns.any{ it.matcher(fqn).matches() }
        if (LOG.isDebugEnabled) {
            LOG.trace("Field {} should be ignored? -> {}", fqn, shouldBeIgnored)
        }
        return shouldBeIgnored
    }

    override fun instrumentDataFetcher(
        dataFetcher: DataFetcher<*>?,
        parameters: InstrumentationFieldFetchParameters?
    ): DataFetcher<*> {
        if (compiledIgnoredFieldsPatterns.isEmpty() || dataFetcher !is PropertyDataFetcher<*>) {
            return super.instrumentDataFetcher(dataFetcher, parameters)
        }
        val env = parameters!!.environment
        val type = (env.parentType as? GraphQLObjectType)?.name ?: "_"
        val field = env.fieldDefinition.name
        return if (shouldIgnore(type, field)) nopDataFetcher
               else super.instrumentDataFetcher(dataFetcher, parameters)
    }

    companion object {
        val nopDataFetcher = DataFetcher { _ -> null }
        val LOG = LoggerFactory.getLogger(GraphqlFieldFilteringInstrument::class.java)
    }
}
