{{define "base_package" (concat service.namespace '.rpc.rest') ~}}
{{define "package" (concat base_package '.' (lower-snake rest_resource.name)) ~}}
{{define "depends_on_cache" (any rest_resource.operations '@it.effective_cache_policy') ~}}
{{define "base_class_name" (upper-camel rest_resource.name) ~}}
{{define "class_name" (concat base_class_name 'RestResourceClient') ~}}
package {{package}}

import org.springframework.stereotype.Component
import org.springframework.web.util.UriBuilder
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpMethod
{{#if depends_on_cache ~}}
import org.springframework.cache.CacheManager
import reactor.core.publisher.Mono
{{~/if}}
import java.util.concurrent.CompletableFuture
import java.util.concurrent.Future
import com.fasterxml.jackson.module.kotlin.*
import org.slf4j.*

import {{base_package}}.RestResourceClientBase
{{#each rest_resource.operations as |operation| ~}}
import {{package}}.{{lower-snake operation.name}}.*
{{/each}}

@Component
class {{class_name}}(
    {{#each rest_resource.configurations as |config| ~}}
    @Value("{{concat '\${' config.definition.key '}'}}")
    private val {{config.variable_name}}: {{upper-camel config.definition.type}},
    {{/each}}
    {{#if depends_on_cache ~}}
    private val cacheManager: CacheManager,
    {{~/if}}
): RestResourceClientBase(), {{upper-camel rest_resource.name}}RestResource {
    {{#each rest_resource.operations as |operation| ~}}
    {{define 'operation_name' (lower-camel operation.name) ~}}
    {{define 'operation_class_base_name' (upper-camel operation.name) ~}}
    {{define 'input_class_name' (concat operation_class_base_name 'Input') ~}}
    {{define 'response_class_name' (concat operation_class_base_name 'Response') ~}}
    {{define 'cache_policy' operation.effective_cache_policy ~}}
    /**
     * {{trim operation.description}}
     */
    override fun {{operation_name}}(
        input: {{input_class_name}}
    {{#if (not cache_policy) ~}}
    ): CompletableFuture<{{response_class_name}}> {
    {{~else~}}
    ): CompletableFuture<{{response_class_name}}> =
        withCache(
            cacheManager.getCache("{{cache_policy.key}}")!!,
            this::{{operation_name}}NoCache,
        )(input)
        {{#if cache_policy ~}}
        .toFuture()
        {{~/if}}

    private fun {{operation_name}}NoCache(
        input: {{input_class_name}}
    ): Mono<{{response_class_name}}> {
    {{~/if}}
        {{#each operation.arguments as |argument| ~}}
        val {{lower-camel argument.name}} = input.{{lower-camel argument.name}}
        {{/each}}
        return client({{dquote rest_resource.base_url}})
        .method(HttpMethod.{{upper-snake operation.method}})
        .uri { it
            .path({{dquote operation.path}})
            {{#each operation.query_parameters as |parameter| ~}}
            .let { {{if parameter.multiple 'queryParams' 'queryParam'}}(it, {{dquote parameter.name}}, {{dquote parameter.value}}) }
            {{/each}}
            .build(mapOf(
                {{#each operation.path_parameters as |param| ~}}
                "{{lower-camel param.name}}" to {{dquote param.value}},
                {{/each}}
            ))
        }
        .let { commonRequestSettings(it) }
        {{#each operation.http_headers as |header| ~}}
        .header({{dquote header.name}}, {{dquote header.value}})
        {{/each}}
        .retrieve()
        .bodyToMono({{upper-camel operation.name}}Response::class.java)
        {{#if (not cache_policy) ~}}
        .toFuture()
        {{~/if}}
    }
    {{/each}}

    companion object {
        private val LOG: Logger = LoggerFactory.getLogger({{class_name}}::class.java)
    }
}