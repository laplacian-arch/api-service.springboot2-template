{{#define "repository_name"}}{{top_level.class_name}}Repository{{/define}}
{{#define "package"}}{{top_level.namespace}}.entity.{{lower-snake top_level.name}}{{/define}}
package {{package}}
import org.springframework.stereotype.Component
import org.springframework.data.r2dbc.core.DatabaseClient
import java.util.concurrent.CompletableFuture
import {{top_level.namespace}}.entity.RepositoryBase
{{#each top_level.relating_top_level_entities as |other| ~}}
import {{other.namespace}}.entity.{{lower-snake other.name}}.{{upper-camel other.name}}Entity
import {{other.namespace}}.entity.{{lower-snake other.name}}.{{upper-camel other.name}}SearchInput
{{/each}}

/**
 * An implementation of the {{repository_name}}.
 */
@Component
class {{repository_name}}Impl(
    private val db: DatabaseClient
): RepositoryBase(db), {{repository_name}} {
{{#*inline "METHOD_DEFINITION_FOR_AN_ENTITY"}}
    {{define "plural_name" (plural entity.name) ~}}
    {{define "entity_class_name" (concat (upper-camel entity.name) 'Entity') ~}}
    {{define "search_input_class_name" (concat (upper-camel entity.name) 'SearchInput') ~}}
    {{define "loader_method_name" (concat 'load' (upper-camel plural_name)) ~}}
    {{define "finder_method_name" (concat 'find' (upper-camel plural_name)) ~}}
    {{define "counter_method_name" (concat 'count' (upper-camel plural_name)) ~}}
    {{define "fqn" entity.fqn ~}}
    {{#each data_accesses as |data_access| ~}}
    {{#if (eq data_access.entity.fqn fqn) ~}}
    {{define "method_name" (lower-camel data_access.name) ~}}
    override fun {{method_name}}(): CompletableFuture<{{data_access.type}}> =
        {{shift data_access.script_body 8}}
    {{/if}}
    {{/each}}

    /**
     * Finds {{plural_name}}.
     */
    override fun {{finder_method_name}}(input: {{search_input_class_name}}): CompletableFuture<Set<{{entity_class_name}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{lower-snake entity.owned_by.name}}_{{lower-snake pk.name}},
          {{/each}}
          {{#each entity.primary_keys as |pk| ~}}
          {{lower-snake pk.name}}{{#unless @last}},{{/unless}}
          {{/each}}
        ${queryOf{{upper-camel finder_method_name}}(input)}
        """.trim())
        .let { bindParamsOf{{upper-camel finder_method_name}}Query(it, input) }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).toSet() }
        .toFuture()

    override fun {{counter_method_name}}(input: {{search_input_class_name}}): CompletableFuture<Long> =
        db
        .execute("SELECT count(*) AS count ${queryOf{{upper-camel finder_method_name}}(input)}")
        .let { bindParamsOf{{upper-camel finder_method_name}}Query(it, input) }
        .fetch()
        .first()
        .map{ it["count"] as Long }
        .toFuture()

    fun bindParamsOf{{upper-camel finder_method_name}}Query(
        sql: DatabaseClient.GenericExecuteSpec, input: {{search_input_class_name}}
    ): DatabaseClient.GenericExecuteSpec {
        var result = sql
        {{#each entity.stored_properties as |p| ~}}
        {{define "prop_name" (lower-camel p.name) ~}}
        {{#if (eq p.type 'string') ~}}
        result = embedSearchParamsForStringField(result, input.{{prop_name}}, "{{prop_name}}")
        {{/if}}
        {{#if (eq p.type 'number') ~}}
        result = embedSearchParamsForIntField(result, input.{{prop_name}}, "{{prop_name}}")
        {{/if}}
        {{/each}}
        return result
    }

    fun queryOf{{upper-camel finder_method_name}}(input: {{search_input_class_name}}): String = """
        FROM
          {{table-name entity.name}}
        ${if (input.isEmpty()) "" else """
        WHERE
          {{#each entity.stored_properties as |p| ~}}
          {{define "prop_name" (lower-camel p.name) ~}}
          {{define "col_name" (column-name p.name) ~}}
          {{define "table_name" (table-name entity.name) ~}}
          {{#if (eq p.type 'string') ~}}
          ${searchConditionForStringField(input.{{prop_name}}, "{{table_name}}.{{col_name}}", "{{prop_name}}")}
          {{/if}}
          {{#if (eq p.type 'number') ~}}
          ${searchConditionForIntField(input.{{prop_name}}, "{{table_name}}.{{col_name}}", "{{prop_name}}")}
          {{/if}}
          {{/each}}
        """}
        """
        .trimMargin()
        .replace("""(\n|^)\s*(--.*)?(\n|$)""", "")
        .replace("""AND\s*$""".toRegex(), "")

    /**
     * Loads {{plural_name}} having the given keys.
     */
    override fun {{loader_method_name}}(keys: Set<{{entity_class_name}}>): CompletableFuture<Set<{{entity_class_name}}>> =
        db.execute(
        """
        SELECT
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{column-name entity.owned_by.name}}_{{column-name pk.name}},
          {{/each}}
          {{#each entity.stored_properties as |property| ~}}
          {{column-name property.name}}{{#unless @last}},{{/unless}}
          {{/each}}
        FROM
          {{table-name entity.name}}
        WHERE
        -- ${keys.mapIndexed{ index, _ -> """
          {{#each entity.owner.primary_keys as |pk| ~}}
          {{define 'col_name' (column-name (concat entity.owned_by.name ' ' pk.name)) ~}}
        {{#unless @first ~}}
        AND
        {{/unless}}
          {{table-name entity.name}}.{{col_name}} = :{{lower-camel col_name}}${index}
          {{/each}}
          {{#each entity.primary_keys as |pk| ~}}
        {{#unless (and (not entity.owner) @first) ~}}
        AND
        {{/unless}}
          {{table-name entity.name}}.{{lower-snake pk.name}} = :{{lower-camel pk.name}}${index}
          {{/each}}
        -- """}.joinToString("\nOR\n")}
        """.trimMargin())
        .let { sql ->
            keys.foldIndexed(sql){ index, acc, key ->
                var binder = acc
                {{#each entity.owner.primary_keys as |pk| ~}}
                {{define 'col_name' (column-name (concat entity.owned_by.name ' ' pk.name)) ~}}
                {{define 'key_name' (lower-camel col_name) ~}}
                {{define 'nullable' pk.nullable ~}}
                binder ={{#if nullable}} if (key.{{key_name}} == null) binder else{{/if}} binder.bind("{{key_name}}${index}", key.{{key_name}}{{if nullable '!!'}})
                {{/each}}
                {{#each entity.primary_keys as |pk| ~}}
                {{define 'key_name' (lower-camel pk.name) ~}}
                {{define 'nullable' pk.nullable ~}}
                binder ={{#if nullable}} if (key.{{key_name}} == null) binder else{{/if}} binder.bind("{{key_name}}${index}", key.{{key_name}}{{if nullable '!!'}})
                {{/each}}
                binder
            }
        }
        .fetch()
        .all()
        .collectList()
        .map { {{entity_class_name}}.fromRecords(it).toSet() }
        .toFuture()

    {{#each entity.stored_relationships as |r| ~}}
    {{define "reference_entity" r.reference_entity ~}}
    {{define "reference_entity_name" (upper-camel r.reference_entity.name) ~}}
    {{define "reference_entity_class_name" (concat reference_entity_name 'Entity') ~}}
    {{define "reference_entity_search_input_name" (concat reference_entity_name 'SearchInput') ~}}
    {{define "result_type" (if r.multiple
      (concat 'List<' reference_entity_class_name '>')
      (concat reference_entity_class_name (if r.nullable '?' ''))
    ) ~}}
    {{define "loader_method_name" (concat 'load' (upper-camel r.name) 'Of' (upper-camel entity.name)) ~}}
    {{define "derived_key_prefix" reference_entity.owned_by.name ~}}
    /**
     * Loads {{r.name}} of this {{entity.name}}.
     */
    override fun {{loader_method_name}}(
        inputs: Map<{{reference_entity_search_input_name}}, Set<{{entity_class_name}}>>
    ): CompletableFuture<Map<Pair<{{reference_entity_search_input_name}}, {{entity_class_name}}>, {{result_type}}>> =
        db.execute(
        """
        SELECT
          ${if (inputs.isEmpty()) "" else """
          _condition_.id AS "_condition_id_",
          """}
          {{#each entity.primary_keys as |pk| ~}}
          {{define 'is_last' (and @last (not reference_entity.primary_keys)) ~}}
          {{#if r.aggregate ~}}
          {{define 'derived_pk_name' (column-name (concat derived_key_prefix '_' pk.name)) ~}}
          {{table-name entity.name}}.{{column-name pk.name}} AS "{{column-name pk.name}}",
          {{table-name reference_entity.name}}.{{derived_pk_name}} AS "{{column-name r.name}}.{{derived_pk_name}}"{{if is_last '' ','}}
          {{else}}
          {{table-name entity.name}}.{{column-name pk.name}} AS "{{column-name pk.name}}"{{if is_last '' ','}}
          {{/if}}
          {{/each}}
          {{#each reference_entity.primary_keys as |pk| ~}}
          {{table-name reference_entity.name}}.{{column-name pk.name}} AS "{{column-name r.name}}.{{column-name pk.name}}"{{if @last '' ','}}
          {{/each}}
        FROM
          ${if (inputs.isEmpty()) "" else """
          (VALUES ${inputs.entries.mapIndexed{ i, _ -> "(${i})"}.joinToString(", ")}) _condition_(id),
          """}
          {{table-name entity.name}},
          {{table-name reference_entity.name}}
        WHERE
        {{#if r.aggregate ~}}
          {{#each entity.primary_keys as |pk| ~}}
        {{if @first '' 'AND'}}
          {{table-name entity.name}}.{{column-name pk.name}} = {{table-name reference_entity.name}}.{{column-name (concat derived_key_prefix ' ' pk.name)}}
          {{/each}}
        {{else}}
          {{#each r.mappings as |mapping| ~}}
        {{if @first '' 'AND'}}
          {{table-name entity.name}}.{{column-name mapping.from}} = {{table-name reference_entity.name}}.{{column-name mapping.to}}
          {{/each}}
        {{/if}}
        AND (
        ${inputs.entries.mapIndexed{ i, (input, keys) -> """
          {{define 'has_nullable_props' (any r.mappings '@it.property.nullable') ~}}
          (${keys.mapIndexed{ index, {{if has_nullable_props 'key' '_'}} -> """
          {{#if r.aggregate ~}}
          {{#each entity.primary_keys as |pk| ~}}
          {{if @first '' 'AND'}}
            {{table-name reference_entity.name}}.{{column-name (concat derived_key_prefix ' ' pk.name)}} = :{{lower-camel derived_key_prefix}}{{upper-camel pk.name}}_${i}_${index}
          {{/each}}
          {{else}}
          {{#each r.mappings as |mapping| ~}}
          {{define 'from_name' (lower-camel mapping.from) ~}}
          {{define 'nullable' mapping.property.nullable ~}}
          {{if @first '' 'AND'}}
            {{table-name reference_entity.name}}.{{column-name mapping.to}} = {{#if nullable}}${if (key.{{from_name}} == null) "null" else "{{/if}}:{{from_name}}_${i}_${index}{{if nullable '"}'}}
          {{/each}}
          {{/if}}
          -- """}.joinToString("\nOR\n")}
          )
          AND
            ${if (input.isEmpty()) "" else """
            {{#each reference_entity.stored_properties as |p| ~}}
            {{define "prop_name" (lower-camel p.name) ~}}
            {{define "col_name" (column-name p.name) ~}}
            {{define "table_name" (table-name reference_entity.name) ~}}
            {{#if (eq p.type 'string') ~}}
            ${searchConditionForStringField(input.{{prop_name}}, "{{table_name}}.{{col_name}}", "{{prop_name}}_${i}_")}
            {{/if}}
            {{#if (eq p.type 'number') ~}}
            ${searchConditionForIntField(input.{{prop_name}}, "{{table_name}}.{{col_name}}", "{{prop_name}}_${i}_")}
            {{/if}}
            {{/each}}
            """}
             _condition_.id = ${i}
        """}.joinToString("\nOR\n")}
         )
        """
        .trimMargin()
        .replace("""(\n|^)\s*(--.*)?(\n|$)""", "")
        .replace("""AND\s*$""".toRegex(), "")
        .let {
            var sql = it
            inputs.entries.mapIndexed{ i, (input, keys) ->
                sql = keys.foldIndexed(sql) { index, acc, key ->
                    var binder = acc
                    {{#if r.aggregate ~}}
                    {{#each entity.primary_keys as |pk| ~}}
                    {{define 'prop_name' (concat (lower-camel derived_key_prefix) (upper-camel pk.name) '_${i}_${index}') ~}}
                    {{define 'pk_name' (lower-camel pk.name) ~}}
                    {{define 'nullable' pk.nullable ~}}
                    binder ={{#if nullable}} if (key.{{pk_name}} == null) binder else{{/if}} binder.bind("{{prop_name}}", key.{{pk_name}}{{if nullable '!!'}})
                    {{/each}}
                    {{else}}
                    {{#each r.mappings as |mapping|}}
                    {{define 'from_name' (lower-camel mapping.from) ~}}
                    {{define 'nullable' mapping.property.nullable ~}}
                    binder ={{#if nullable}} if (key.{{from_name}} == null) binder else{{/if}} binder.bind("{{from_name}}_${i}_${index}", key.{{from_name}}{{if nullable '!!'}})
                    {{/each}}
                    {{/if}}
                    binder
                }
                {{#each reference_entity.stored_properties as |p| ~}}
                {{define "prop_name" (lower-camel p.name) ~}}
                {{define "col_name" (column-name p.name) ~}}
                {{define "table_name" (table-name reference_entity.name) ~}}
                {{#if (eq p.type 'string') ~}}
                sql = embedSearchParamsForStringField(sql, input.{{prop_name}}, "{{prop_name}}_${i}_")
                {{/if}}
                {{#if (eq p.type 'number') ~}}
                sql = embedSearchParamsForIntField(sql, input.{{prop_name}}, "{{prop_name}}_${i}_")
                {{/if}}
                {{/each}}
            }
            sql
        }
        .fetch()
        .all()
        .collectList()
        .map { records ->
            {{entity_class_name}}.fromRecordsGrouping(records) { record ->
                val searchConditionIndex = record["_condition_id_"]
                if (searchConditionIndex == null || searchConditionIndex !is Int) {
                    {{reference_entity_search_input_name}}()
                }
                else {
                    inputs.keys.toList().getOrElse(searchConditionIndex){ {{reference_entity_search_input_name}}() }
                }
            }.flatMap { (searchCondition, {{lower-camel (plural entity.name)}}) ->
                {{lower-camel (plural entity.name)}}.map { {{lower-camel entity.name}} -> searchCondition to {{lower-camel entity.name}} }
            }
            .map { it to it.second.{{lower-camel r.name}} }
            .toMap()
        }
        .toFuture()
    {{/each}}
{{/inline}}
    {{#each top_level.aggregated_entities as |e| ~}}
    {{> METHOD_DEFINITION_FOR_AN_ENTITY entity=e ~}}
    {{/each}}
}
