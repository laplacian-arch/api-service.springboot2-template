package {{service.namespace}}.configuration

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.ApplicationContext
import org.springframework.util.StreamUtils
import org.springframework.web.reactive.function.server.router
import org.springframework.web.reactive.function.server.ServerRequest
import graphql.schema.GraphQLSchema
import graphql.GraphQL
import graphql.schema.idl.SchemaParser
import graphql.schema.idl.SchemaGenerator
import org.dataloader.DataLoader;
import org.dataloader.DataLoaderRegistry;
import {{service.namespace}}.query.QueryResolver
{{#each service.top_level_entities_backing_graphql_type as |top_level| ~}}
{{define "entity_package" (concat
    top_level.namespace '.entity.' (lower-underscore top_level.identifier
)) ~}}
import {{entity_package}}.{{top_level.class_name}}Resolver
{{~#if top_level.aggregates}}
{{#each top_level.aggregates as |aggregate| ~}}
import {{entity_package}}.{{aggregate.reference_entity.class_name}}Resolver
{{/each}}
{{/if}}
{{/each}}
{{#each service.graphql_types_backed_by_indexed_document as |graphql_type| ~}}
{{define "index_name" graphql_type.elasticsearch_index.name ~}}
import {{service.namespace}}.search.{{lower-snake index_name}}.*
{{/each}}
{{#each service.graphql_types_backed_by_external_rest_resource as |graphql_type| ~}}
{{define "rest_resource_name" graphql_type.rest_resource.name ~}}
import {{service.namespace}}.rpc.rest.{{lower-snake rest_resource_name}}.*
{{/each}}
import java.nio.charset.StandardCharsets
import graphql.schema.idl.RuntimeWiring
import graphql.scalars.ExtendedScalars

@Configuration
class GraphqlConfig {

    @Bean
    fun graphql(
        schema: GraphQLSchema
    ): GraphQL = GraphQL.newGraphQL(schema).build()

    @Bean
    fun buildSchema(
        context: ApplicationContext,
        runtimeWiring: RuntimeWiring
    ): GraphQLSchema {
        val parser = SchemaParser()
        val schema = context
            .getResources("classpath*:/**/*.graphql")
            .map {
                StreamUtils.copyToString(it.inputStream, StandardCharsets.UTF_8)
            }
            .joinToString("\n")
        val typeRegistry = parser.parse(schema)
        return SchemaGenerator().makeExecutableSchema(typeRegistry, runtimeWiring)
    }

    @Bean
    fun buildRuntimeWiring(
        queryResolver: QueryResolver,
        {{#each service.entities_backing_graphql_type as |entity| ~}}
        {{lower-camel entity.name}}Resolver: {{upper-camel entity.name}}Resolver,
        {{/each}}
        {{#each service.graphql_types_backed_by_indexed_document as |graphql_type| ~}}
        {{define "index_name" graphql_type.elasticsearch_index.name ~}}
        {{lower-camel index_name}}Resolver: {{upper-camel index_name}}Resolver,
        {{lower-camel index_name}}DocumentResolver: {{upper-camel index_name}}DocumentResolver,
        {{/each}}
        {{#each service.graphql_types_backed_by_external_rest_resource as |graphql_type| ~}}
        {{define "rest_resource_name" graphql_type.rest_resource.name ~}}
        {{lower-camel rest_resource_name}}Resolver: {{upper-camel rest_resource_name}}Resolver,
        {{/each}}
    ): RuntimeWiring = RuntimeWiring.newRuntimeWiring()
    .scalar(ExtendedScalars.newRegexScalar("DateTime").addPattern(
        """^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$""".toPattern()
    ).build())
    .scalar(ExtendedScalars.newRegexScalar("Date").addPattern(
        """^[0-9]{4}-[0-9]{2}-[0-9]{2}$""".toPattern()
    ).build())
    .scalar(ExtendedScalars.Time)
    .also {
        queryResolver.registerFetcher(it)
        {{#each service.entities_backing_graphql_type as |entity| ~}}
        {{lower-camel entity.name}}Resolver.registerFetcher(it)
        {{/each}}
        {{#each service.graphql_types_backed_by_indexed_document as |graphql_type| ~}}
        {{define "index_name" graphql_type.elasticsearch_index.name ~}}
        {{lower-camel index_name}}Resolver.registerFetcher(it)
        {{lower-camel index_name}}DocumentResolver.registerFetcher(it)
        {{/each}}
        {{#each service.graphql_types_backed_by_external_rest_resource as |graphql_type| ~}}
        {{define "rest_resource_name" graphql_type.rest_resource.name ~}}
        {{lower-camel rest_resource_name}}Resolver.registerFetcher(it)
        {{/each}}
    }.build()

    @Bean
    fun buildDataLoaderRegistry(
        {{#each service.graphql_type_relationships as |relationship| ~}}
        {{#if (eq relationship.type 'indexed_document') ~}}
        {{lower-camel relationship.resolver_name}}: {{upper-camel relationship.resolver_name}},
        {{/if}}
        {{/each}}
    ): DataLoaderRegistry = DataLoaderRegistry().also {
        {{#each service.graphql_type_relationships as |relationship| ~}}
        {{#if (eq relationship.type 'indexed_document') ~}}
        {{lower-camel relationship.resolver_name}}.registerLoader(it)
        {{/if}}
        {{/each}}
    }
}