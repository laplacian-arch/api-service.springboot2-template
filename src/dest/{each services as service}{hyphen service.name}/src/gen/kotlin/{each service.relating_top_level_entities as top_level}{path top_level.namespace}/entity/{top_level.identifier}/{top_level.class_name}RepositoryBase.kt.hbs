{{#define "repository_name"}}{{top_level.class_name}}Repository{{/define}}
{{#define "package"}}{{top_level.namespace}}.entity.{{top_level.identifier}}{{/define}}
package {{package}}
import kotlinx.coroutines.future.future
import kotlinx.coroutines.runBlocking
import {{service.namespace}}.entity.db.tables.{{top_level.class_name}}
{{#each top_level.relating_entities as |e|}}
import {{service.namespace}}.entity.db.tables.{{e.class_name}}
{{/each}}
import {{service.namespace}}.util.*
import org.jooq.DSLContext
import org.jooq.impl.DSL.row
import org.springframework.stereotype.Component
import java.util.concurrent.CompletableFuture

/**
 * An implementation of the {{repository_name}}.
 */
@Component
class {{repository_name}}Base(
    private val dsl: DSLContext
): {{repository_name}} {
{{#*inline "TABLE_ALIAS"}}
    private val {{lower-camel entity.identifier}}: {{entity.class_name}} = {{entity.class_name}}.{{upper-underscore entity.identifier}}
{{/inline}}
    {{> TABLE_ALIAS entity=top_level}}
    {{#each top_level.relating_entities as |e|}}
    {{> TABLE_ALIAS entity=top_level entity=e}}
    {{/each}}

{{#*inline "METHOD_DEFINITION_FOR_AN_ENTITY"}}
    {{#define "plural_name"}}{{plural entity.name}}{{/define}}
    {{#define "entity_class_name"}}{{entity.class_name}}Entity{{/define}}
    {{#define "entity_set"}}Set<{{entity_class_name}}>{{/define}}
    {{#define "loader_method_name"}}load{{upper-camel plural_name}}{{/define}}
    {{#define "fqn"}}{{entity.fqn}}{{/define}}
    {{#define "lname"}}{{lower-camel entity.identifier}}{{/define}}

    {{#each data_accesses as |data_access|}}
    {{#if (eq data_access.entity.fqn fqn)}}
    {{#define "method_name"}}{{lower-camel data_access.identifier}}{{/define}}
    override fun {{method_name}}(): {{data_access.type}} =
        {{shift data_access.script_body 8}}

    override fun {{method_name}}Async(): CompletableFuture<{{data_access.type}}> =
        runBlocking { future { getDecks() } }
    {{/if}}
    {{/each}}

    override fun {{loader_method_name}}(keys: {{entity_set}}): {{entity_set}} =
        dsl
        .select()
        .from({{lname}})
        {{#if (eq entity.primary_key_names.size 0)}}
        {{else if (eq entity.primary_key_names.size 1)}}
        {{define "pk" entity.primary_key_names.[0]}}
        .where({{lname}}.{{upper-underscore pk}}.In(keys.map{ it.{{lower-camel pk}} }.distinct()))
        {{else}}
        .where(
            row(
                {{#each entity.primary_key_names as |pk|}}{{lname}}.{{upper-underscore pk}}{{#unless @last}}, {{/unless}}{{/each}}
            )
            .In(keys.map{ row(
                {{#each entity.primary_key_names as |pk|}}it.{{lower-camel pk}}{{#unless @last}}, {{/unless}}{{/each}}
            )})
        )
        {{/if}}
        .fetchInto({{entity_class_name}}::class.java)
        .toSet()

    override fun {{loader_method_name}}Async(keys: {{entity_set}}): CompletableFuture<{{entity_set}}> =
        runBlocking { future { {{loader_method_name}}(keys)} }

    {{#each entity.stored_relationships as |r|}}
    {{#if r.multiple}}
    {{#define "reference_entity_class_name"}}{{r.reference_entity.class_name}}Entity{{/define}}
    {{#define "loader_method_name"}}load{{upper-camel r.property_name}}Of{{upper-camel entity.name}}{{/define}}
    {{#define "lname_ref"}}{{lower-camel r.reference_entity.identifier}}{{/define}}
    override fun {{loader_method_name}}(keys: Set<{{entity_class_name}}>): Map<{{entity_class_name}}, List<{{reference_entity_class_name}}>> =
        dsl
        .select(
            {{lname}}.asterisk(),
            {{lname_ref}}.asterisk()
        )
        .from({{lname}})
        .join({{lname_ref}})
        {{#each entity.primary_keys as |pk|}}
        .on({{lname}}.{{upper-underscore pk.identifier}}.eq({{lname_ref}}.{{upper-underscore lname}}_{{upper-underscore pk.identifier}}))
        {{/each}}
        {{#if (eq entity.primary_key_names.size 0)}}
        {{else if (eq entity.primary_key_names.size 1)}}
        {{define "pk" entity.primary_key_names.[0]}}
        .where({{lname}}.{{upper-underscore pk}}.In(keys.map{ it.{{lower-camel pk}} }.distinct()))
        {{else}}
        .where(
            row(
                {{#each entity.primary_key_names as |pk|}}{{lname}}.{{upper-underscore pk}}{{#unless @last}}, {{/unless}}{{/each}}
            )
            .In(keys.map{ row(
                {{#each entity.primary_key_names as |pk|}}it.{{lower-camel pk}}{{#unless @last}}, {{/unless}}{{/each}}
            )})
        )
        {{/if}}
        .fetch()
        .intoGroups({{entity_class_name}}::class.java, {{reference_entity_class_name}}::class.java)

    override fun {{loader_method_name}}Async(keys: Set<{{entity_class_name}}>): CompletableFuture<Map<{{entity_class_name}}, List<{{reference_entity_class_name}}>>> =
        runBlocking { future { {{loader_method_name}}(keys)} }
    {{/if}}
    {{/each}}
{{/inline}}

    {{#each top_level.aggregated_entities as |e|}}
    {{> METHOD_DEFINITION_FOR_AN_ENTITY entity=e}}
    {{/each}}

}
