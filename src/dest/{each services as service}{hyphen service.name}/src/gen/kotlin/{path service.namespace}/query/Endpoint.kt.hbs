{{#define "package"}}{{service.namespace}}.query{{/define}}
package {{package}}

import com.coxautodev.graphql.tools.SchemaParser
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import graphql.ExecutionInput
import graphql.GraphQL.*
{{#each service.relating_top_level_entities as |top_level|}}
{{#define "entity_package"}}{{top_level.namespace}}.entity.{{lower-underscore top_level.identifier}}{{/define}}
import {{entity_package}}.{{top_level.class_name}}Resolver
{{#each top_level.aggregates as |aggregate|}}
import {{entity_package}}.{{aggregate.reference_entity.class_name}}Resolver
{{/each}}
{{/each}}
{{#each service.relating_top_level_entities as |top_level|}}
import {{service.namespace}}.entity.db.tables.records.{{top_level.class_name}}Record
{{/each}}
import org.dataloader.DataLoaderRegistry
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.core.io.ClassPathResource
import org.springframework.web.reactive.function.BodyInserters
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse
import org.springframework.web.reactive.function.server.bodyToMono
import org.springframework.web.reactive.function.server.router
import reactor.core.publisher.Mono

typealias ReactiveProcessor = (request: ServerRequest) -> Mono<ServerResponse>

@Configuration
class Endpoint(
    val queryResolver: QueryResolver,
    {{#each service.relating_entities as |e|}}
    val {{lower-camel e.identifier}}Resolver: {{e.class_name}}Resolver{{#unless @last}},{{/unless}}
    {{/each}}
) {
    val schema = lazy {
        SchemaParser.newParser()
        .files(
            {{#each service.relating_top_level_entities as |top_level|}}
            "{{path top_level.namespace}}/entity/{{lower-underscore top_level.identifier}}/{{top_level.class_name}}.graphqls",
            {{#each top_level.aggregates as |aggregate|}}
            "{{path top_level.namespace}}/entity/{{lower-underscore top_level.identifier}}/{{aggregate.reference_entity.class_name}}.graphqls",
            {{/each}}
            {{/each}}
            "{{path service.namespace}}/query/Query.graphqls"
        )
        .resolvers(
            {{#each service.relating_top_level_entities as |top_level|}}
            {{lower-camel top_level.identifier}}Resolver,
            {{#each top_level.aggregates as |aggregate|}}
            {{lower-camel aggregate.reference_entity.identifier}}Resolver,
            {{/each}}
            {{/each}}
            queryResolver
        )
        .build()
        .makeExecutableSchema()
    }

    @Bean
    fun graphiql() = router {
        println(schema)
        GET("/", staticFile("/index.html"))
        GET("/{{lower-underscore service.identifier}}/{{service.api_version}}/graphiql.html", staticFile("/graphiql.html"))
        POST("/{{lower-underscore service.identifier}}/{{service.api_version}}/graphql").invoke {
            processGraphQl(it)
        }
    }

    data class GraphqlParams(
        val query: String,
        val operationName: String? = null,
        val variables: String? = null
    )

    fun graphqlOptionFromBody(request: ServerRequest): Mono<GraphqlParams> = request.bodyToMono<String>().map { json ->
        val params = jacksonObjectMapper().readValue(json, HashMap::class.java)
        GraphqlParams(
            query = params["query"]!!.toString()
        )
    }

    fun dataloaderRegistry() = DataLoaderRegistry().also {
        {{#each service.relating_top_level_entities as |top_level|}}
        {{lower-camel top_level.identifier}}Resolver.registerLoader(it)
        {{#each top_level.aggregates as |aggregate|}}
        {{lower-camel aggregate.reference_entity.identifier}}Resolver.registerLoader(it)
        {{/each}}
        {{/each}}
    }

    fun processGraphQl(request: ServerRequest): Mono<ServerResponse> = graphqlOptionFromBody(request).flatMap { params ->
        val graphQl = newGraphQL(schema.value).build()
        val query = ExecutionInput
            .newExecutionInput()
            .query(params.query)
            .dataLoaderRegistry(dataloaderRegistry())
            .build()
        ServerResponse.ok().body(
            BodyInserters.fromObject(graphQl.execute(query).getData<Any>())
        )
    }

    fun staticFile(resourcePath: String): ReactiveProcessor = {
        ServerResponse.ok().body(
            BodyInserters.fromResource(ClassPathResource(resourcePath))
        )
    }
}


